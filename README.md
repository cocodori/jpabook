# 자바 ORM 표준 JPA 프로그래밍

## 1. 데이터 중심 설계의 문제점

테이블 외래키를 객체에 그대로 가져온 부분, 이를 테 OrderItem클래스의 orderId나, itemId 같은 부분은 문제가 될 수 있다.
왜냐하면 관계형 데이터베이스는 연관된 객체를 찾을 때 외래키를 이용해서 조인하면 되지만, 객체에는 조인이라는 기능이 없다. 객체는
연관된 객체를 찾을 때 **참조**를 사용한다. 

 지금처럼 객체를 참조하지 않고, 외래키를 그대로 가지고 있으면 order.getMember()처럼 객체 그래프 탐색을 할 수 없다.
 이렇게 외래키만 가지고 있으면 연관된 엔티티를 찾을 때 외래 키로 데이터베이스에 다시 조회해야 한다.
 
 ```java
Order order = em.find(Order.class, orderId);

//외래 키로 다시 조회
Member member = em.find(Member.class, order.getMemberId();
``` 

참조를 이용하면 더 간편하게 조회할 수 있다.

```java
Order oder = em.find(Order.class , orderId);
//참조를 사용하므로 다시 DB에 조회할 필요가 없다.
Member member = order.getMember(); 
```
객체는 참조를 사용해서 연관된 객체를 찾고, 데이터베이스는 외래 키를 사용해서 연관된 테이블을 찾는다.
JPA는 객체의 참조와 테이블의 외래킬를 매핑해서 객체에서는 참조를, 테이블에서는 외래 키를 사용할 수 있도록 지원한다.

## 2. 데이터베이스의 연관관계와 객체의 연관관계

데이터베이스는 FK 하나만으로 양방향 참조가 가능하다. 하지만 객체에는 FK가 없다. 양방향도 없다. 양방향을 참조하려면 양쪽에서 서로를 참조하는, 
서로 다른 방향을 가진 두 개의 참조가 필요하다.

@ManyToOne과 @OneToMany로 양방향 관계를 맺어줄 수 있다. PK를 가진 엔티티(@OneToMany) 쪽에서 FK를 가진 엔티티를 조회할 일이 없다면
양방향 참조를 사용할 때까지 뒤로 밀어도 좋다. JPA는 양방향 연관관계를 사용할 때 주인이 아닌 엔티티는 @MappedBy를 이용해 반드시 연관관계의 주인을 명시해야 한다.
mappdBy는 주인이 아닌 엔티티에만 존재해야 한다.
누가 연관관계의 주인일까? FK를 가진 엔티티가 연관관계의 주인이다. 즉 @ManyToOne을 가진 엔티티가 연관관계의 주인이 된다.




